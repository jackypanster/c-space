# **C盘大文件清理工具 - 开发计划**

本项目将遵循以下分步计划进行开发。每一步完成后，都会提供可运行的代码和明确的验收标准。只有在当前步骤验收通过后，才会进入下一步的开发。

---

### **第一步：项目初始化与参数解析**

*   **任务**:
    1.  创建主 Python 脚本文件 `c_cleaner.py`。
    2.  使用 `argparse` 库搭建命令行界面框架。
    3.  添加一个位置参数 `path` 用于指定扫描路径（默认为 `'C:\'`）。
    4.  实现对 `--min-size` 和 `--top` 选项参数的解析，并设置 PRD 中规定的默认值。
    5.  实现一个简单的函数来解析 `100MB`, `1GB` 这样的人性化输入，并转换为字节数。
*   **验收标准**:
    -   运行 `python c_cleaner.py` 时，程序能正常启动并使用默认值（扫描路径为 `C:\`）。
    -   运行 `python c_cleaner.py D:\` 时，程序能正确识别扫描路径为 `D:\`。
    -   运行 `python c_cleaner.py --min-size 200MB --top 10` 时，程序能正确解析并打印出对应的参数值（例如：最小大小为 209715200 字节，显示数量为 10）。
    -   对于无效输入（如 `--min-size 100X`），程序能给出友好的错误提示并退出。

---

### **第二步：实现文件扫描与安全排除**

*   **任务**:
    1.  编写核心的扫描函数，使用 `os.walk()` 遍历从参数中获取的用户指定路径。
    2.  实现 PRD 中定义的**排除规则**：
        -   获取并标准化所有需要排除的系统目录路径。
        -   在遍历时，跳过这些被排除的目录。
        -   检查并跳过带有“系统”和“隐藏”属性的文件。
    3.  在扫描过程中加入基本的进度提示（例如，打印当前正在扫描的顶层目录）。
    4.  使用 `try...except` 块处理 `PermissionError` 等潜在的 OS 错误，确保扫描过程不会因个别文件或目录的访问问题而中断。
*   **验收标准**:
    -   扫描函数能返回一个包含 `(文件路径, 文件大小)` 元组的列表。
    -   在测试中，该函数能正确跳过指定的排除目录和具有系统/隐藏属性的文件。
    -   即使遇到无权限访问的目录，程序也能继续扫描其他部分而不是崩溃。

---

### **第三步：结果排序、格式化与展示**

*   **任务**:
    1.  对扫描结果列表按文件大小进行降序排序。
    2.  根据 `--top` 参数截取最终要显示的列表。
    3.  编写一个辅助函数，将字节大小格式化为易读的 `KB`, `MB`, `GB` 字符串。
    4.  按照 PRD 中定义的表格样式，将最终结果清晰地打印到控制台。
*   **验收标准**:
    -   给定一个模拟的文件列表，输出的表格格式、排序、数量限制和文件大小单位均与 PRD 中的示例完全一致。

---

### **第四步：实现交互式安全删除**

*   **任务**:
    1.  引入 `send2trash` 库。
    2.  在结果展示后，启动一个循环，逐一询问用户是否删除文件。
    3.  根据用户输入 (`y`/`n`/`q`) 执行相应操作：移至回收站、跳过或退出。
    4.  将“跳过”（按 Enter）设为默认操作。
    5.  使用 `try...except` 捕获删除操作可能出现的异常（如文件被占用），并向用户报告错误。
*   **验收标准**:
    -   程序能正确地与用户进行交互。
    -   输入 `y` 后，测试文件被移动到操作系统的回收站中。
    -   输入 `n` 或直接回车，程序会跳过当前文件。
    -   输入 `q`，程序会立即终止删除流程。
    -   删除一个不存在或被锁定的文件时，程序会打印错误信息并继续下一个。

---

### **第五步：整合、完善与打包**

*   **任务**:
    1.  添加最终的健壮性检查，如启动时判断是否在 Windows 系统上运行。
    2.  整理代码，添加必要的注释和文档字符串。
    3.  编写一个简单的 `README.md` 说明如何使用该工具。
*   **验收标准**:
    -   最终的 `c_cleaner.py` 脚本可以从头到尾完整地执行所有功能。

---

### **第六步：代码质量重构 (Code Quality Refactoring)**

*   **任务**:
    1.  **引入 `rich` 库**:
        *   将 `rich` 添加到 `requirements.txt`。
        *   使用 `rich.table.Table` 重构 `display.py` 中的 `display_results` 函数，以简化代码并提升视觉效果。
    2.  **全面采用 `pathlib`**:
        *   在所有 Python 脚本 (`scanner.py`, `deleter.py`, `path_handler.py`, etc.) 中，将 `os.path` 的用法替换为 `pathlib.Path` 对象。
        *   确保路径拼接、文件名提取和存在性检查等操作都通过 `pathlib` 的方法完成。
    3.  **常量集中管理**:
        *   创建一个 `constants.py` 或在 `utils.py` 中定义一个专门的区域。
        *   将项目中硬编码的字符串（如 `.cleaner_ignore`）和配置值（如默认排除目录）移动到该处进行统一管理。
*   **验收标准**:
    -   程序运行时，结果以 `rich` 库渲染的表格正确显示。
    -   代码中不再出现 `os.path` 的直接使用，所有路径操作均由 `pathlib` 完成。
    -   硬编码的常量被移除，改为从统一的模块中导入。
    -   重构后的程序功能与之前完全一致，并通过所有既有功能的测试。
